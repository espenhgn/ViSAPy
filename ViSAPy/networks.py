#!/usr/bin/env python
'''
Spiking-neuron (network) models implemented in NEST
'''
import numpy as np
import os
import sys
if sys.version < '3':
    if not os.environ.has_key('DISPLAY'):
        import matplotlib
        matplotlib.use('Agg')
else:
    if 'DISPLAY' in os.environ.keys():
        import matplotlib
        matplotlib.use('Agg')
import h5py
import matplotlib.pyplot as plt
from matplotlib import gridspec
import nest
from mpi4py import MPI
from nest import topology
from ViSAPy import GDF, NonStationaryPoisson


#set some plot attributes
plt.rcdefaults()
plt.rcParams.update({
    'font.size' : 16,
    'axes.labelsize' : 16,
    'axes.titlesize' : 16,
    'legend.fontsize' : 14,
    'xtick.labelsize' : 10,
    'ytick.labelsize' : 10,
    'figure.subplot.wspace' : 0.4,
    'figure.subplot.hspace' : 0.4,
    
})


################# Initialization of MPI ########################################
COMM = MPI.COMM_WORLD
SIZE = COMM.Get_size()
RANK = COMM.Get_rank()


################# Class definitions ############################################

class Network(object):
    '''    
    Parent network class, defining common methods for inherited network
    class objects
    '''
    def __init__(self,
                 simtime=1000.,
                 dt = 0.1,
                 total_num_virtual_procs = SIZE,
                 savefolder = 'savedata',
                 label = 'spikes',
                 to_file = True,
                 to_memory = False,
                 print_time=False,
                 ):
        '''
        Initialization of class Network.
        
        Keyword arguments:
        ::
        
            simtime : float, simulation duration
            dt : float, temporal solution of simulation
            total_num_virtual_procs : int, number of virtual threads in NEST
            savefolder : str, path to saved file output from NEST
            label : str, fileprefix of spike output files generated by NEST
            to_file : bool, flag for recording spike times onto file in NEST
            to_memory : bool, flag for recording spike times into memory in NEST
            print_time : bool, flag for printing simulation time in NEST
            
            
        '''
        #set attributes
        self.simtime = simtime
        self.dt = dt
        self.savefolder = savefolder
        self.label = label
        self.to_file = to_file
        self.to_memory = to_memory
        self.total_num_virtual_procs = total_num_virtual_procs
        self.print_time = print_time

        #create savedata folder if it doesn't exist
        if RANK == 0:
            if not os.path.isdir(self.savefolder):
                os.system('mkdir %s' % self.savefolder)
            
            #put revision info in savefolder
            try:
                os.system('git rev-parse HEAD -> %s/NetworkRevision.txt' % \
                        self.savefolder)
            except:
                pass

        COMM.Barrier()
        
        #None-type some vars that may be created by the subclasses
        self.NE = None
        self.NI = None
        self.p_rate = None
        self.espikes = None
        self.ispikes = None
        self.N = None
        self.nodes_ex = None
        self.nodes_in = None
        
        #reset NEST kernel and set kernel status
        nest.ResetKernel()
        
        #set kernel attributes
        nest.SetKernelStatus({
            "print_time": self.print_time,
            "overwrite_files" : True,
            "total_num_virtual_procs" : self.total_num_virtual_procs
        })
        #if dt is in powers of two, dt must be multiple of ms_per_tic
        if self.dt in 2**np.arange(-32., 0):
            nest.SetKernelStatus({
                "tics_per_ms" : 2**2 / self.dt,
                "resolution": self.dt,
            })
        else:
            nest.SetKernelStatus({
                "resolution": self.dt,
            })
        
        
        #set defaults for spike detektor mechanism
        nest.SetDefaults("spike_detector",
                         {
                            "withtime": True,
                            "withgid" : True,
                            "to_file" : self.to_file,
                            "to_memory" : self.to_memory,
                            "flush_after_simulate" : True,
                            "close_after_simulate" : True,
                         })        

    def run(self):
        '''
        Run nest.Simulate until simtime
        
        This method takes no keyword arguments
        '''
        #Sync
        COMM.Barrier() 
        
        if RANK == 0:
            print('running nest.Simulate until simtime=%.2f' % self.simtime)
        nest.Simulate(self.simtime)
        
        if RANK == 0:
            print('simulation finished')
        
        COMM.Barrier()


    def setup_spike_detector(self):
        '''
        Create spike Nest spike_detector mechanism.
        
        This method takes no keyword arguments

        Returns:
        ::
            
            ((int), (int)) : tuple of tuples with spike detektor GIDs
        '''
        if RANK == 0:
            print('setting up spike detectors')

        #create spike detektor for excitatory and inhibitory populations
        espikes = nest.Create("spike_detector", 1,
                              {
                                "label": os.path.join(self.savefolder,
                                                      self.label) + "-ex"
                                })
        ispikes = nest.Create("spike_detector", 1,
                              {
                                "label": os.path.join(self.savefolder,
                                                      self.label) + "-in"
                                })

        return espikes, ispikes


    def setup_external_input(self):
        '''
        Set up and create external Poisson input with rate Network.p_rate
        
        This method takes no keyword arguments
        
        Returns:
        ::
            
            (int) : GID of Poisson generator
        '''
        if RANK == 0:
            print('setting up poisson_generator')
                
        #create Poisson generator with specific rate
        noise = nest.Create("poisson_generator", 1, {"rate": self.p_rate})
        
        return noise


    def get_results(self):
        '''
        Compute and print out some statistics of network simulation
        
        This method takes no keyword arguments
        '''
        if self.espikes is None and self.ispikes is None:
            print('nothing to print because there are no spike recorders')
            return
        
        #gather data
        num_synapses_ex = nest.GetDefaults("excitatory")["num_connections"]
        num_synapses_in = nest.GetDefaults("inhibitory")["num_connections"]
        # if RANK == SIZE - 1:
        #     # spikes only exist on the last RANK with nest.SetNumRecProcesses(1)
        #     eevents = nest.GetStatus(self.espikes, "n_events")[0]
        #     ievents = nest.GetStatus(self.ispikes, "n_events")[0]
        #     erate   = float(eevents) / self.simtime * 1000. / self.NE
        #     irate   = float(ievents) / self.simtime * 1000. / self.NI
        # else:
        #     erate = None
        #     irate = None

        eevents = nest.GetStatus(self.espikes, "n_events")[0]
        ievents = nest.GetStatus(self.ispikes, "n_events")[0]
        erate   = float(eevents) / self.simtime * 1000. / self.NE
        irate   = float(ievents) / self.simtime * 1000. / self.NI

        #broadcast network rates to all RANKs
        erate = COMM.reduce(erate)
        irate = COMM.reduce(irate)

        #print out statistics
        if RANK == 0:
            print("Number of exc synapses/neuron:", num_synapses_ex / float(self.N))
            print("Number of inh synapses/neuron:", num_synapses_in / float(self.N))
            print("Number of synapses:", num_synapses_in+num_synapses_ex)
            print("Synapse density:", (num_synapses_in+num_synapses_ex) / float(self.N**2))
            print("Ratio number of exc/inh synapses:", num_synapses_ex / float(num_synapses_in))
            print("Excitatory rate       : %.2f Hz" % erate)
            print("Inhibitory rate       : %.2f Hz" % irate)
        
        COMM.Barrier()

        
    def raster_plots(self, xlim=(0., 1000.), from_db=True):
        '''
        Plot network activity
        
        Keyword arguments:
        ::
            
            xlim : length 2 tuple of floats, lower and upper time limit in plot
            from_db : bool, if True, load simulation output from sqlite database
        
        
        Returns:
        ::
            
            matplotlib.figure.Figure object on RANK 0, None otherwise
        
        '''
        if self.nodes_ex is None and self.nodes_in is None:
            print("No nodes exist for {}, plot not possible".format(self))
            return
        
        if from_db and RANK == 0:
            db = GDF(os.path.join(self.savefolder, 'SpTimesEx.db'),
                     new_db=False)
            xe = np.array([])
            ye = np.array([])
            spiketimes = db.select_neurons_interval(np.array(self.nodes_ex
                                                            ).flatten(), T=xlim)
            i = 0
            for times in spiketimes:
                xe = np.r_[xe, times]
                ye = np.r_[ye, np.zeros(times.size) + np.array(self.nodes_ex
                                                            ).flatten()[i]]
                i += 1
            db.close()
        elif not from_db:
            #load only spiketimes up to xlim, excitatory
            xe = nest.GetStatus(self.espikes)[0]['events']['times']
            inds = (xe <= xlim[1]) & (xe >= xlim[0])
            xe = xe[inds]
            ye = nest.GetStatus(self.espikes)[0]['events']['senders'][inds]
        
            #broadcast the times, senders
            COMM.bcast(xe, root=0)
            COMM.bcast(ye, root=0)
        else:
            return

        if from_db and RANK == 0:
            db = GDF(os.path.join(self.savefolder, 'SpTimesIn.db'),
                                  new_db=False)
            xi = np.array([])
            yi = np.array([])
            spiketimes = db.select_neurons_interval(np.array(self.nodes_in
                                                            ).flatten(), T=xlim)
            i = 0
            for times in spiketimes:
                xi = np.r_[xi, times]
                yi = np.r_[yi, np.zeros(times.size) + np.array(self.nodes_in
                                                            ).flatten()[i]]
                i += 1            
            db.close()         
        elif not from_db:
            #load only spiketimes up to xlim, inhibitory
            xi = nest.GetStatus(self.ispikes)[0]['events']['times']
            inds = (xi <= xlim[1]) & (xi >= xlim[0])
            xi = xi[inds]
            yi = nest.GetStatus(self.ispikes)[0]['events']['senders'][inds]

            #broadcast the times, senders
            COMM.bcast(xi, root=0)
            COMM.bcast(yi, root=0)
        else:
            return

        if RANK == 0:
            fig = plt.figure(figsize=(10, 7))
            
            ax = fig.add_axes([0.1, 0.6, 0.8, 0.3])
            ax.plot(xe, ye, 'o',
                    markersize=1,
                    markerfacecolor='r',
                    markeredgecolor='r',
                    alpha=0.5,
                    label='exc', rasterized=True)
            
            ax.plot(xi, yi, 'o',
                    markersize=1,
                    markerfacecolor='b',
                    markeredgecolor='b',
                    alpha=0.5,
                    label='inh', rasterized=True)
            
            ax.axis([xlim[0], xlim[1], 0, yi.max()])
            ax.set_ylabel('cell id')
            
            leg = ax.legend()
            for t in leg.get_texts():
                t.set_fontsize('small')    # the legend text fontsize
            ax.set_title('spike raster')
            for loc, spine in ax.spines.iteritems():
                if loc in ['right', 'top']:
                    spine.set_color('none')
            ax.xaxis.set_ticks_position('bottom')
            ax.yaxis.set_ticks_position('left')
            
            ax.text(-0.1, 1.0, 'a',
                horizontalalignment='center',
                verticalalignment='center',
                fontsize=20, fontweight='demibold',
                transform=ax.transAxes)
            


            
            ax = fig.add_axes([0.1, 0.35, 0.8, 0.15])
            bins = np.arange(xlim[0], xlim[1]+1)
            hist = ax.hist(xe,
                bins=bins,
                color='r', label='exc', histtype='stepfilled', edgecolor='none',
                rasterized=True)
            hist = np.array(hist[0])
            
            ax.hist(xi,
                bins=bins,
                color='b', label='inh', histtype='stepfilled', edgecolor='none',
                rasterized=True)
            
            ax.set_ylabel('spikes / ms')
            ax.set_xlim(xlim[0], xlim[1])
            ax.set_ylim(0, hist.max())
            del hist
            
            leg = ax.legend()
            for t in leg.get_texts():
                t.set_fontsize('small')    # the legend text fontsize

            for loc, spine in ax.spines.iteritems():
                if loc in ['right', 'top']:
                    spine.set_color('none')
            ax.xaxis.set_ticks_position('bottom')
            ax.yaxis.set_ticks_position('left')
            
            ax.text(-0.1, 1.0, 'b',
                horizontalalignment='center',
                verticalalignment='center',
                fontsize=20, fontweight='demibold',
                transform=ax.transAxes)

            ax.set_title('spike count histogram')
            
            ax = fig.add_axes([0.1, 0.1, 0.8, 0.15])
            bins = np.arange(xlim[0], xlim[1]+1)
            hist = np.histogram(
                xe,
                bins=bins)[0]
            ax.plot(bins[:-1], hist * 1000 / self.NE,
                    color='r', label='exc', rasterized=True)
            
            hist = np.histogram(
                xi,
                bins=bins)[0]
            ax.plot(bins[:-1], hist * 1000 / self.NI,
                    color='b', label='inh', rasterized=True)
            ax.set_xlabel(r'$t$ (ms)', labelpad=0.1)
            ax.set_ylabel('rate (Hz)')
            ax.set_xlim(xlim[0], xlim[1])
            
            leg = ax.legend()
            for t in leg.get_texts():
                t.set_fontsize('small')    # the legend text fontsize

            for loc, spine in ax.spines.iteritems():
                if loc in ['right', 'top']:
                    spine.set_color('none')
            ax.xaxis.set_ticks_position('bottom')
            ax.yaxis.set_ticks_position('left')
            
            ax.set_title('population firing rate (Hz)')
            
            ax.text(-0.1, 1.0, 'c',
                horizontalalignment='center',
                verticalalignment='center',
                fontsize=20, fontweight='demibold',
                transform=ax.transAxes)
            

            return fig
        else:
            return


    def process_gdf_files(self):
        '''
        Create sqlite databases on disk allowing fast enquires of spike events.
        Relies on class ViSAPy.GDF
        
        This method takes no keyword arguments
        '''
        if RANK == 0:
    
            # create db from excitatory files
            f = os.path.join(self.savefolder, 'SpTimesEx.db')
            print('creating database file {}'.format(f))
            
            db = GDF(f, debug=True)
            db.create(re=os.path.join(self.savefolder, self.label) + '-ex-*.gdf',
                      index=True)
            db.close()
    
            # create db from inhibitory files
            f = os.path.join(self.savefolder, 'SpTimesIn.db')
            print('creating database file {}'.format(f))
            
            db = GDF(f, debug=True)
            db.create(re=os.path.join(self.savefolder, self.label) + '-in-*.gdf',
                      index=True)
            db.close()

        COMM.Barrier()


class StationaryPoissonNetwork(Network):
    '''
    Class StationaryPoissonNetwork, inherites class Network
    
    Creates a pool of stationary Poissonian spike trains using NEST, one pool
    for excitatory synapses and another for inhibitory synapses
    '''
    def __init__(self,
                 NE = 10000,
                 NI = 2500,
                 frateE = 10.,
                 frateI = 10.,
                 **kwargs):
        '''
        Initialization of class StationaryPoissonNetwork,
        inherites class Network

        Creates a pool of stationary Poissonian spike trains using NEST, one pool
        for excitatory synapses and another for inhibitory synapses
        
        Keyword arguments:
        ::
            
            NE : int, Number of excitatory cells
            NI : int, Number of inhibitory cells
            frateE: float, firing rate of stationary Poisson rate, excitatory
            frateI: float, firing rate of stationary Poisson rate, inhibitory
            
            **kwargs : see class Network
        
        '''
        #initialize parent class
        Network.__init__(self, **kwargs)

        #set some attributes
        self.NE = NE
        self.NI = NI
        self.frateE = frateE
        self.frateI = frateI

        #synapse model
        nest.CopyModel("static_synapse", "excitatory", {})
 
        #create the populations
        self.nodes_ex = nest.Create('parrot_neuron', self.NE)
        self.nodes_in = nest.Create('parrot_neuron', self.NI)
        
        #create spike detectors
        self.espikes, self.ispikes = self.setup_spike_detector()

        #create independent poisson spike trains with the some rate,
        #but each layer population should really have different rates
        self.noiseE = self.setup_external_input(self.frateE)
        self.noiseI = self.setup_external_input(self.frateI)

        #connect the devices
        self.connect_devices()


    def setup_external_input(self, rate):
        '''
        Set up and create external Poisson input.
        
        This method patches method Network.setup_external_input to accept
        an arbitrary rate as input.
        
        Keyword arguments:
        ::
            
            rate : float, rate of external Poisson generator
        
        Returns:
        ::
        
            tuple of int, GID of Poisson generator mechanism        
        '''
        if RANK == 0:
            print('setting up poisson_generator')
        
        #create poisson generator    
        #noise = nest.Create("poisson_generator", 1, {"rate": rate})
        noise = nest.Create("sinusoidal_poisson_generator", 1,
                            {"rate" : rate,
                             "amplitude" : rate/2.,
                             "frequency" : 5.,
                             "phase" : 360 / np.pi})


        return noise


    def connect_devices(self):
        '''
        connect network devices
        
        This method takes no keyword arguments
        '''
        if RANK == 0:
            print('connecting spike detectors to nodes')
        nest.Connect(self.nodes_ex, self.espikes, conn_spec='all_to_all',
                     syn_spec=dict(model="excitatory"))
        nest.Connect(self.nodes_in, self.ispikes, conn_spec='all_to_all',
                     syn_spec=dict(model="excitatory"))

        if RANK == 0:
            print('connecting noise generators and nodes')
        nest.Connect(self.noiseE, self.nodes_ex, conn_spec='all_to_all',
                     syn_spec=dict(model="excitatory"))
        nest.Connect(self.noiseI, self.nodes_in, conn_spec='all_to_all',
                     syn_spec=dict(model="excitatory"))


    def get_results(self):
        '''
        Compute and print out some statistics of network simulation
        
        This method takes no keyword arguments
        '''
        
        #gather data
        if RANK == SIZE - 1:
            # spikes only exist on the last RANK with nest.SetNumRecProcesses(1)
            eevents = nest.GetStatus(self.espikes, "n_events")[0]
            ievents = nest.GetStatus(self.ispikes, "n_events")[0]
            erate   = float(eevents) / self.simtime * 1000. / self.NE
            irate   = float(ievents) / self.simtime * 1000. / self.NI
        else:
            erate = None
            irate = None

        #broadcast network rates to all RANKs
        erate = COMM.bcast(erate, root=SIZE - 1)
        irate = COMM.bcast(irate, root=SIZE - 1)

        if RANK == 0:
            print("Excitatory rate       : %.2f Hz" % erate)
            print("Inhibitory rate       : %.2f Hz" % irate)



class BrunelNetwork(Network):
    '''
    Class BrunelNetwork, inherites class Network

    This class implements a leaky integrate-and-fire network similar to
    Brunel, N. Journal of Computational Neuroscience 8, 183-208 (2000)
    and is based off the NEST example file
    "pynest/examples/brunel-alpha-nest.py"
    
    '''
    def __init__(self,
                order=2500,
                eta=2.0,
                epsilon=0.1,
                J=0.1,
                g=5.0,
                delay=1.5,
                tauMem = 20.,
                theta = 20.,
                **kwargs
        ):
        '''
        Initialization of class BrunelNetwork, inherites class Network
    
        This class implements a leaky integrate-and-fire network similar to
        Brunel, N. Journal of Computational Neuroscience 8, 183-208 (2000)
        and is based off the NEST example file
        "pynest/examples/brunel-alpha-nest.py"
        
        Keyword arguments:
        ::
            
            order : int, size of inhibitory population, excitatory population
                size is 4 times order
            eta : float, ratio between external and threshold rate
            epsilon : float, connection probability
            J : float, excitatory synapse weight, i.e.,
                postsynaptic potential amplitude in mV
            g : float, relative inhibition strength
            delay : float, mean connection delay in network in ms
            tauMem : float, membrane time constant in ms
            theta : float, spike threshold in mV
            **kwargs : see parent class ViSAPy.Network

        '''
        #initialize parent class
        Network.__init__(self, **kwargs)
        
        #set some attributes
        self.order = order
        self.NE = 4 * self.order
        self.NI = 1 * self.order
        self.N = self.NE + self.NI
        self.g = g
        self.eta = eta
        self.epsilon = epsilon
        self.CE = int(self.epsilon*self.NE) # n excitatory synapses per neuron
        self.CI = int(self.epsilon*self.NI) # n inhibitory synapses per neuron
        self.J = J
        self.J_ex = self.J
        self.J_in = -self.g * self.J_ex
        self.tauMem = tauMem
        self.theta = theta
        self.nu_th  = self.theta / (self.J*self.CE*self.tauMem)
        self.nu_ex  = self.eta*self.nu_th
        self.p_rate = 1000.0*self.nu_ex*self.CE
        self.delay = delay

        #create dictionary for LIF neuron params
        self.neuron_params = {
                        "C_m":        1.0,
                        "tau_m":      self.tauMem,
                        "t_ref":      2.0,
                        "E_L":        0.0,
                        "V_reset":    0.0,
                        "V_m":        0.0,
                        "V_th":       self.theta}

        #create mechanisms, connect network
        self.nodes_ex, self.nodes_in = self.build_network()
        self.noise = self.setup_external_input()
        self.espikes, self.ispikes = self.setup_spike_detector()
        self.create_synapses()
        self.connect_devices()


    def create_synapses(self):
        '''
        Create excitatory and inhibitory synapses.
        
        This method takes no keyword arguments.
        '''
        nest.CopyModel("static_synapse", "excitatory",
                       {"weight" : self.J_ex, "delay" : self.delay})
        nest.CopyModel("static_synapse", "inhibitory",
                       {"weight" : self.J_in, "delay" : self.delay})
        

    def build_network(self):
        '''
        Build the network
        
        This method takes no keyword arguments.
        
        Returns:
        ::
            
            ((int), (int)) : tuple of tuples with neuron GIDs
        '''
        if RANK == 0:
            print("Building network")

        nest.SetDefaults("iaf_psc_delta", self.neuron_params)

        nodes_ex = nest.Create("iaf_psc_delta", self.NE)
        nodes_in = nest.Create("iaf_psc_delta", self.NI)

        return nodes_ex, nodes_in


    def connect_devices(self):
        '''
        Connect all network devices.
        
        This method takes no keyword arguments.
        '''
        if RANK == 0:
            print('connecting devices')
        
        if RANK == 0:
            print('connecting noise generators and nodes')
        nest.Connect(self.noise, self.nodes_ex,
                     conn_spec='all_to_all',
                     syn_spec=dict(model="excitatory"))
        nest.Connect(self.noise, self.nodes_in,
                     conn_spec='all_to_all',
                     syn_spec=dict(model="excitatory"))

        if RANK == 0:
            print('connecting spike detectors')
        nest.Connect(self.nodes_ex, self.espikes,
                     conn_spec='all_to_all',
                     syn_spec=dict(model="excitatory"))
        nest.Connect(self.nodes_in, self.ispikes,
                     conn_spec='all_to_all',
                     syn_spec=dict(model="excitatory"))


        if RANK == 0:
            print('connecting nodes')

        nest.Connect(self.nodes_ex,
                     self.nodes_ex+self.nodes_in,
                     conn_spec=dict(rule='fixed_indegree', indegree=self.CE),
                     syn_spec=dict(model="excitatory"))
        nest.Connect(self.nodes_in,
                     self.nodes_ex+self.nodes_in,
                     conn_spec=dict(rule='fixed_indegree', indegree=self.CI),
                     syn_spec=dict(model="inhibitory"))


class RingNetwork(Network):
    '''
    Class RingNetwork, inherites class Network

    This class implements a leaky integrate-and-fire network similar to:
    
    Birgit Kriener, Moritz Helias, Ad Aertsen and Stefan Rotter.
    "Correlations in spiking neuronal networks with distance dependent
    connections". J Comput Neurosci (2009) 27:177-200.
    DOI 10.1007/s10827-008-0135-1
    '''
    def __init__(self,
                N = 2500,
                epsilon = 0.1,
                theta = 20.,
                tauMem = 20.,
                delay = 2.,
                J_ex = 0.1,
                g = 6.,
                eta = 1.5,
                allow_autapses = False,
                allow_multapses = False,
                exc_inh_assymetry = 1.,
                **kwargs
        ):
        '''
        Initialization of class RingNetwork, inherites class Network
    
        This class implements a leaky integrate-and-fire network similar to:
        
        Birgit Kriener, Moritz Helias, Ad Aertsen and Stefan Rotter.
        "Correlations in spiking neuronal networks with distance dependent
        connections". J Comput Neurosci (2009) 27:177-200.
        DOI 10.1007/s10827-008-0135-1


        Keyword arguments:
        ::
            
            N : int, full network size, inhibitory population size is N/5
            epsilon : mask width parameter, where the mask width of the
                network connectivity will be set as int(epsilon*N)
            theta : float, spike threshold in mV
            tauMem : float, membrane time constant in ms
            delay : float, mean connection delay in network in ms
            J_ex : float, excitatory synapse weight, i.e.,
                postsynaptic potential amplitude in mV
            g : float, relative inhibition strength
            eta : float, ratio between external and threshold rate
            allow_autapses : Bool, allow connections to self
            allow_multapses : Bool, allow multiple synapses per connection
            exc_inh_assymetry : float, relative width of inhibitory vs.
                excitatory connections, values > 1 means inhibitory range is
                greater than excitatory range
            **kwargs : see parent class ViSAPy.Network


        '''
        #initialize parent class
        Network.__init__(self, **kwargs)
        
        #set some attributes
        self.N          =  N
        self.epsilon    =  epsilon
        self.NE         =  int(0.8*self.N)
        self.NI         =  self.N-self.NE
        self.K          =  int(epsilon/2*self.N)
        self.theta      =  theta
        self.tauMem     =  tauMem
        self.delay      =  delay
        self.g          =  g
        self.J_ex       =  J_ex
        self.J_in       = -self.g*self.J_ex
        self.eta        =  eta
        self.p_rate     =  self.eta*1000.
        self.allow_autapses = allow_autapses
        self.allow_multapses = allow_multapses
        if exc_inh_assymetry != 1.:
            try:
                assert(allow_multapses)
            except AssertionError as ae:
                raise ae('allow_multapses must be True for exc_inh_assymetry != 1')
        self.exc_inh_assymetry = exc_inh_assymetry

        #create dictionary for LIF neuron params
        self.neuron_params = {
                        "C_m"       :  250.,      # Capacitance in [pF]
                        "tau_m"     :  self.tauMem,
                        "t_ref"     :  2.0,      # refractory period [ms]
                        "E_L"       :  0.0,      # resting mem potential [mV]
                        "V_reset"   :  0.0,
                        "V_th"      :  self.theta
        }
        
        #create mechanisms, connect network
        self.nodes_ex, self.nodes_in = self.build_network()
        self.noise = self.setup_external_input()
        self.espikes, self.ispikes = self.setup_spike_detector()
        self.connect_devices()


    def build_network(self):
        '''
        Define parameters of neuron, if not further specified,
        default parameters are used.
        To see them, look at nest/models/iaf_psc_alpha.cpp or use GetStatus:
        '''
        #Set neuron parameters:
        nest.SetDefaults("iaf_psc_delta", self.neuron_params)
                
        #Create layers:
        gridconst = 1. / self.N
        pos_ex = np.array([[], []])
        pos_in = np.array([[], []])
        for i in range(self.N):
            if np.mod(i, 5) == 0:
                pos_in = np.append(pos_in, np.array([[0.5],
                                        [gridconst / 2. + i*gridconst]]),
                                   axis=1)
            else:
                pos_ex = np.append(pos_ex, np.array([[0.5],
                                        [gridconst / 2. + i*gridconst]]),
                                   axis=1)
        
        #dict for layer properties
        exc_set = {"positions": list(pos_ex.T),
                   "elements" : "iaf_psc_delta",
                   "edge_wrap": True,
                   "extent" :   [2 * gridconst, 1.],
                   "center" :   [0.5, 0.5]
                   }
        
        #create layer, get nodes
        exc = topology.CreateLayer(exc_set)
        nodes_ex = nest.GetLeaves(exc)

        #dict for layer properties
        inh_set = {"positions": list(pos_in.T),
                   "elements" : "iaf_psc_delta",
                   "edge_wrap": True,
                   "extent" :   [2 * gridconst, 1.],
                   "center" :   [0.5, 0.5]
                   }

        #create layer, get nodes
        inh = topology.CreateLayer(inh_set)
        nodes_in = nest.GetLeaves(inh)

        #Set up connection profiles:
        #nest.SetDefaults("static_synapse", {"delay": self.delay})
        nest.CopyModel("static_synapse", "excitatory", {})
        nest.CopyModel("static_synapse", "inhibitory", {})

        #connection parameters
        exc_par = {
            "connection_type" : "convergent",
            "mask"            : {
                 "rectangular": {
                     "lower_left" :     [0.5*(1.-gridconst),
                                        -(self.K+0.5)*gridconst / self.exc_inh_assymetry],
                     "upper_right" :    [0.5*(1.+gridconst),
                                        (self.K+0.5)*gridconst / self.exc_inh_assymetry]}},
             "weights"         : self.J_ex,
             "delays"          : self.delay,
             "synapse_model"   : "excitatory",
             "allow_autapses"  : self.allow_autapses,
             "allow_multapses" : self.allow_multapses
             }

        inh_par = {
            "connection_type" : "convergent",
            "mask"            : {
                 "rectangular": {
                     "lower_left" :     [0.5 * (1. - gridconst),
                                        -(self.K + 0.5) * gridconst * self.exc_inh_assymetry],
                     "upper_right" :    [0.5 * (1. + gridconst),
                                        (self.K + 0.5) * gridconst * self.exc_inh_assymetry]}},
             "weights"         : self.J_in,
             "delays"          : self.delay,
             "synapse_model"   : "inhibitory",
             "allow_autapses"  : self.allow_autapses,
             "allow_multapses" : self.allow_multapses
             }

        #Connect layers:
        if RANK == 0:
            print("Connecting network...")
            print("exc -> exc")
        topology.ConnectLayers(exc, exc, exc_par)
        if RANK == 0:
            print("exc -> inh")
        topology.ConnectLayers(exc, inh, exc_par)
        if RANK == 0:
            print("inh -> exc")
        topology.ConnectLayers(inh, exc, inh_par)
        if RANK == 0:
            print("inh -> inh")
        topology.ConnectLayers(inh, inh, inh_par)

        return nodes_ex, nodes_in


    def connect_devices(self):
        '''
        connect network devices
        
        This method takes no keyword arguments
        '''
        if RANK == 0:
            print('connecting noise generators and nodes')
        nest.Connect(self.noise, self.nodes_ex[0]+self.nodes_in[0],
                     conn_spec='all_to_all')

        if RANK == 0:
            print('connecting spike detectors to nodes')
        nest.Connect(self.nodes_ex[0], self.espikes, conn_spec='all_to_all')
        nest.Connect(self.nodes_in[0], self.ispikes, conn_spec='all_to_all')


class ExternalNoiseRingNetwork(RingNetwork):
    '''
    Class ExternalNoiseRingNetwork, inherites class RingNetwork

    This class implements a leaky integrate-and-fire network similar to:
    
    Birgit Kriener, Moritz Helias, Ad Aertsen and Stefan Rotter.
    "Correlations in spiking neuronal networks with distance dependent
    connections". J Comput Neurosci (2009) 27:177-200.
    DOI 10.1007/s10827-008-0135-1
    
    but with external noise generated by NonStationaryPoisson,
    where the lambda function is determined by spatial mean of
    extracellular noise.
    '''
    def __init__(self,
                 lambda_t,
                 tstop=1000.,
                 invertnoise_ex=True,
                 invertnoise_in=False,
                 rate=20.,
                 projection=['exc', 'inh'],
                 weight=2.,
                 **kwargs):
        '''
        Initialization of class ExternalNoiseRingNetwork,
        inherites class RingNetwork
    
        This class implements a leaky integrate-and-fire network similar to:
        
        Birgit Kriener, Moritz Helias, Ad Aertsen and Stefan Rotter.
        "Correlations in spiking neuronal networks with distance dependent
        connections". J Comput Neurosci (2009) 27:177-200.
        DOI 10.1007/s10827-008-0135-1
        
        but with external noise generated by NonStationaryPoisson,
        where the lambda function is determined by spatial mean of
        extracellular noise.
        
        All N neurons of given time will get some input
        with given rate
        
        Keyword arguments:
        ::
            
            lambda_t : np.ndarray, length (tstop*dt+1) vector representing
                rate expectation for non-stationary Poisson generator, e.g.,
                generated using
                ViSAPy.CorrelatedNoise.correlated_noise(T=tstop).mean(axis=0)
            tstop : float, end of LFPy.Cell simulations
            invertnoise_ex : bool, revert sign of mean noise for generating
                nonstationary input to excitatory population
            invertnoise_in : bool, revert sign of mean noise for generating
                nonstationary input to inhibitory population
            rate : float, mean rate of nonstationary poisson inputs
            projection : list of str, e.g., ['exc', 'inh'] will put noise on
                excitatory and inhibitory populatons
            weight : float, strength of synaptic weights in mV of non-stationary
                Poisson input onto target cells
            
            **kwargs : see parent class RingNetwork and class Network
        
        '''
        #initialize parent class
        RingNetwork.__init__(self, **kwargs)
        
        #set some attributes
        self.lambda_t = lambda_t
        self.tstop = tstop
        self.invertnoise_ex = invertnoise_ex
        self.invertnoise_in = invertnoise_in
        self.rate = rate
        self.projection = projection
        self.weight = weight
        
        ##set up the nonstationary poisson processes
        #self.extracellular_noise = self.get_extracellular_noise()
        
        #preprocess rate expectations to excitatory and inhibitory populations 
        if self.invertnoise_ex:
            lambda_t_e = -self.lambda_t.copy()
        else:
            lambda_t_e = self.lambda_t.copy()
                
        if self.invertnoise_in:
            lambda_t_i = -self.lambda_t.copy()
        else:
            lambda_t_i = self.lambda_t.copy()
        
        #setup parameter dictionary for generation of non-stationary Poisson
        #events
        self.nonStatPoissonParameters = {
            'tvec' : np.arange(self.lambda_t.size) *
                            self.dt,
            'rate' : self.rate,
            }
        
        #Produce non-stationary Poissonian spike trains, read from database
        #if file exists.
        if os.path.isfile(os.path.join(self.savefolder, 'non_stat_spikes.db')):
            db = GDF(os.path.join(self.savefolder, 'non_stat_spikes.db'),
                                  new_db=False)
            self.nonStatPoisson = db.select(db.neurons())
            db.close()
            
            #get the rate functions
            f = h5py.File(os.path.join(self.savefolder, 'ViSAPy_noise.h5'))
            self.lambda_t_E = f['lambda_t_E'].value
            self.lambda_t_I = f['lambda_t_I'].value
            f.close()
        else:
            #container fpr nonstationary times:
            self.nonStatPoisson = []
            
            #extract nonstationary noise inputs for each cell in the network
            if RANK == 0:
                for proj in self.projection:
                    if proj == 'exc':
                        nonStat_E, self.lambda_t_E = self.get_nonstationary_poisson(
                            lambda_t_e, self.NE)
                        self.nonStatPoisson += nonStat_E
                    elif proj == 'inh':
                        nonStat_I, self.lambda_t_I = self.get_nonstationary_poisson(
                            lambda_t_i, self.NI)
                        self.nonStatPoisson += nonStat_I
                    else:
                        raise Exception("projection is not 'exc' and/or 'inh'")
            
                #save lambda_t_E and lambda_t_I in file for plots later
                f = h5py.File(os.path.join(self.savefolder, 'ViSAPy_noise.h5'))
                f['lambda_t_E'] = self.lambda_t_E
                f['lambda_t_I'] = self.lambda_t_I
                f.close()
            
                #save the nonstationary poisson spikes in db
                db = GDF(os.path.join(self.savefolder, 'non_stat_spikes.db'),
                                      new_db=True, debug=True)
                db.create_from_list(re=self.nonStatPoisson)
                db.close()
            
            #sync
            COMM.Barrier()
            
            if RANK != 0:
                db = GDF(os.path.join(self.savefolder, 'non_stat_spikes.db'),
                                      new_db=False)
                self.nonStatPoisson = db.select(db.neurons())
                db.close()
                
                #get the rate functions
                f = h5py.File(os.path.join(self.savefolder,
                                           'ViSAPy_noise.h5'))
                self.lambda_t_E = f['lambda_t_E'].value
                self.lambda_t_I = f['lambda_t_I'].value
                f.close()
            
            COMM.Barrier()
        
        #setup spike generators and connect with neuron populations
        self.spike_generator = self.setup_nonStatPoisson_input()        
        self.connect_nonStatPoisson()


    #def get_extracellular_noise(self):        
    #    '''
    #    Generate extracellular noise, noise mean used to generate
    #    the rate function for the nonstationary poisson process
    #    
    #    This method takes no keyword arguments
    #    '''
    #    if RANK == 0:
    #        #read from file if output exist
    #        if os.path.isfile(os.path.join(self.savefolder,
    #                                       'ViSAPy_noise.h5')):
    #            #open file
    #            f = h5py.File(os.path.join(self.savefolder,
    #                                       'ViSAPy_noise.h5'),
    #                      'r')
    #            #lambda function
    #            lambda_t = f['lambda_t'].value
    #            #close file
    #            f.close()
    #        #if not, create CorrelatedNoise instance, compute extracellular
    #        #noise
    #        else:
    #            cnoise = CorrelatedNoise(**self.correlatedNoiseParameters)
    #            noise = cnoise.correlated_noise(T = self.simtime)
    #            print 'noise ok'
    #                            
    #            
    #            #time vector, save only stuff t >= 0 
    #            tvec = np.arange(0, self.tstop + self.dt, self.dt)
    #            
    #            #save noise so that it can be superimposed onto LFP later
    #            f = h5py.File(os.path.join(self.savefolder,
    #                                       'ViSAPy_noise.h5'))
    #            #dump data
    #            f['data'] = noise[:, tvec >= 0]
    #            
    #            #band-pass filter mean noise before non-stat Poisson generation
    #            b, a = ss.butter(N=2,
    #                             Wn=np.array([1., 25]) / (1000. / self.dt / 2),
    #                             btype='bandpass')
    #            #compute lambda function, use signal averaged over space
    #            lambda_t = ss.filtfilt(b, a, noise.mean(axis=0))
    #
    #            #save lambda function
    #            f['lambda_t'] = lambda_t
    #            
    #            #close file
    #            f.close()
    #            print 'saved extracellular noise'
    #
    #    else:
    #        lambda_t = None
    #    #broadcast the noise
    #    return COMM.bcast(lambda_t, root=0)
        
        
    def get_nonstationary_poisson(self, noise, N):
        '''
        Create non-stationary Poisson spiketrains using the NonStationaryPoisson
        class.
        
        Keyword arguments:
        ::
            
            noise : np.ndarray, expectation rate for Poisson output
            N : int, number of generated Poisson spiketrains
        
        '''
        if RANK == 0:
            print('generating non-stationary Poisson inputs')
        
        if RANK == 0:
            #generate poisson spike time trains
            nonstatpoisson = NonStationaryPoisson(lambda_t=noise, N=N,
                                                  **self.nonStatPoissonParameters)
            poisson = nonstatpoisson.poisson
            lambda_t = nonstatpoisson.lambda_t
        else:
            poisson = None
            lambda_t = None
        
        #return poisson spiketimes and rate function:
        return poisson, lambda_t
        

    def setup_nonStatPoisson_input(self):
        '''
        Set up and create external Poisson input
        
        This method takes no keyword arguments
        '''
        if RANK == 0:
            print('setting up spike_generator')
        
        spike_generator = nest.Create("spike_generator",
                                      len(self.nonStatPoisson))
            
        nest.SetStatus(spike_generator,
                       [{'spike_times' : x[x > 0]} for x in self.nonStatPoisson])
        
        return spike_generator
        
            
    def connect_nonStatPoisson(self):
        '''
        Connect the non-stationary poisson times with target neurons
        
        This method takes no keyword arguments
        '''
        if RANK == 0:
            print('connecting non-stationary poisson times')
        
        i = 0
        for proj in self.projection:
            if proj == 'exc':
                nest.Connect(self.spike_generator[i:i + self.NE],
                             self.nodes_ex[0],
                             conn_spec='one_to_one', 
                             syn_spec=dict(
                                weight=self.weight,
                                delay=1.)
                    )
                i += self.NE
            elif proj == 'inh':
                nest.Connect(self.spike_generator[i:i + self.NI],
                             self.nodes_in[0],
                             conn_spec='one_to_one', 
                             syn_spec=dict(
                                weight=self.weight,
                                delay=1.)
                    )
                i += self.NI
            else:
                messg = "projection {} is not in ['exc' or 'inh']".format(proj)
                raise Exception(messg)


    def raster_plots_full(self, xlim=[0, 1000], from_db=True):
        '''
        plot lambda functions, non-stationary poisson spike trains and network
        activity. 

        Keyword arguments:
        ::
            
            xlim : length 2 tuple of floats, lower and upper time limit in plot
            from_db : bool, if True, load simulation output from sqlite database
        
        
        Returns:
        ::
            
            matplotlib.figure.Figure object on RANK 0, None otherwise
        '''
        tvec = np.arange(self.simtime/self.dt +1) * self.dt
        tslice = (tvec >= xlim[0]) & (tvec <= xlim[1])

        gs = gridspec.GridSpec(10, 1)

        def plot_nonstat(fig, xlim):
            if RANK == 0:

                #plot spatially averaged noise signal
                ax = fig.add_subplot(gs[0])
                ax.plot(tvec[tslice], self.lambda_t[tslice])
                ax.axis(ax.axis('tight'))
                ax.set_title(r'spatially averaged noise $\lambda_t(t)$')
                ax.set_ylabel(r'$\bar{\phi}$ (mV)')
                ax.set_xticks([])
                ax.text(-0.1, 1.0, 'a',
                    horizontalalignment='center',
                    verticalalignment='center',
                    fontsize=18, fontweight='demibold',
                    transform=ax.transAxes)

                
                #plot lambda_t_E and lambda_t_I
                ax0 = fig.add_subplot(gs[1])
                ax0.plot(tvec[tslice], self.lambda_t_E[tslice], 'r',
                         rasterized=True, label=r'$\lambda_\mathrm{E}(t)$')
                ax0.plot(tvec[tslice], self.lambda_t_I[tslice], 'b',
                         rasterized=True, label=r'$\lambda_\mathrm{I}(t)$')
                ax0.axis(ax0.axis('tight'))
                leg = ax0.legend()
                for t in leg.get_texts():
                    t.set_fontsize('small')    # the legend text fontsize
                for loc, spine in ax0.spines.iteritems():
                    if loc in ['right', 'top']:
                        spine.set_color('none')
                ax0.xaxis.set_ticks_position('bottom')
                ax0.yaxis.set_ticks_position('left')
                ax0.set_ylabel(r'$\lambda(t)$ (Hz)')
                ax0.set_title('non-stationary Poisson rate functions')
                ax0.set_xticks([])
                ax0.text(-0.1, 1.0, 'b',
                    horizontalalignment='center',
                    verticalalignment='center',
                    fontsize=18, fontweight='demibold',
                    transform=ax0.transAxes)
    
        
                #plot nonstationary poisson
                ax2 = fig.add_subplot(gs[2:4])
                db = GDF(os.path.join(self.savefolder, 'non_stat_spikes.db'),
                                      new_db=False)
                #excitatory
                neurons = np.array(self.nodes_ex).flatten()
                xns = np.array([])
                yns = np.array([])
                i = 0
                for x in db.select_neurons_interval(neurons, xlim):
                    xns = np.r_[xns, x]
                    yns = np.r_[yns, np.zeros(x.size) + neurons[i]]
                    i += 1
                
                ax2.plot(xns, yns, 'o',
                            markersize=1, markerfacecolor='r', markeredgecolor='r',
                            alpha=0.25, rasterized=True, label='exc')
        
                #inhibitory
                neurons = np.array(self.nodes_in).flatten()
                xns = np.array([])
                yns = np.array([])
                i = 0
                for x in db.select_neurons_interval(neurons, xlim):
                    xns = np.r_[xns, x]
                    yns = np.r_[yns, np.zeros(x.size) + neurons[i]]
                    i += 1
                db.close()
    
                
                ax2.plot(xns, yns, 'o',
                            markersize=1, markerfacecolor='b', markeredgecolor='b',
                            alpha=0.25, rasterized=True, label='inh')
        
                leg = ax2.legend()
                for t in leg.get_texts():
                    t.set_fontsize('small')    # the legend text fontsize
    
        
                for loc, spine in ax2.spines.iteritems():
                    if loc in ['right', 'top']:
                        spine.set_color('none')
                ax2.xaxis.set_ticks_position('bottom')
                ax2.yaxis.set_ticks_position('left')
                ax2.set_ylabel('cell id')
                ax2.axis(ax2.axis('tight'))
                ax2.set_xlim(xlim[0], xlim[1])
                ax2.set_title('non-stationary spikes')
                ax2.set_xticks([])
                ax2.text(-0.1, 1.0, 'c',
                    horizontalalignment='center',
                    verticalalignment='center',
                    fontsize=18, fontweight='demibold',
                    transform=ax2.transAxes)
                
            return fig


        def plot_rasters(fig, xlim, from_db):
            if RANK == 0:
                if from_db and RANK == 0:
                    db = GDF(os.path.join(self.savefolder, 'SpTimesEx.db'),
                             new_db=False)
                    xe = np.array([])
                    ye = np.array([])
                    spiketimes = db.select_neurons_interval(np.array(self.nodes_ex
                                                                    ).flatten(), T=xlim)
                    i = 0
                    for times in spiketimes:
                        xe = np.r_[xe, times]
                        ye = np.r_[ye, np.zeros(times.size) + np.array(self.nodes_ex
                                                                    ).flatten()[i]]
                        i += 1
                    db.close()
                elif not from_db:
                    #load only spiketimes up to xlim, excitatory
                    xe = nest.GetStatus(self.espikes)[0]['events']['times']
                    inds = (xe <= xlim[1]) & (xe >= xlim[0])
                    xe = xe[inds]
                    ye = nest.GetStatus(self.espikes)[0]['events']['senders'][inds]
                
                    #broadcast the times, senders
                    COMM.bcast(xe, root=0)
                    COMM.bcast(ye, root=0)
                else:
                    return
        
                if from_db and RANK == 0:
                    db = GDF(os.path.join(self.savefolder, 'SpTimesIn.db'),
                                          new_db=False)
                    xi = np.array([])
                    yi = np.array([])
                    spiketimes = db.select_neurons_interval(np.array(self.nodes_in
                                                                    ).flatten(), T=xlim)
                    i = 0
                    for times in spiketimes:
                        xi = np.r_[xi, times]
                        yi = np.r_[yi, np.zeros(times.size) + np.array(self.nodes_in
                                                                    ).flatten()[i]]
                        i += 1
                    db.close()         
                elif not from_db:
                    #load only spiketimes up to xlim, inhibitory
                    xi = nest.GetStatus(self.ispikes)[0]['events']['times']
                    inds = (xi <= xlim[1]) & (xi >= xlim[0])
                    xi = xi[inds]
                    yi = nest.GetStatus(self.ispikes)[0]['events']['senders'][inds]
        
                    #broadcast the times, senders
                    COMM.bcast(xi, root=0)
                    COMM.bcast(yi, root=0)
                else:
                    return
        
                if RANK == 0:
                    #fig.suptitle('Spike rasters, spike histogram, firing rate')
                    
                    ax = fig.add_subplot(gs[4:6])
                    ax.plot(xe, ye, 'o',
                            markersize=1,
                            markerfacecolor='r',
                            markeredgecolor='r',
                            alpha=0.5,
                            label='exc', rasterized=True)
                    
                    ax.plot(xi, yi, 'o',
                            markersize=1,
                            markerfacecolor='b',
                            markeredgecolor='b',
                            alpha=0.5,
                            label='inh', rasterized=True)
                    
                    ax.axis([xlim[0], xlim[1],
                             np.min(self.nodes_ex), np.max(self.nodes_in)])
                    ax.set_ylabel('cell id')
                    
                    leg = ax.legend()
                    for t in leg.get_texts():
                        t.set_fontsize('small')    # the legend text fontsize
                    ax.set_title('spike raster')
                    for loc, spine in ax.spines.iteritems():
                        if loc in ['right', 'top']:
                            spine.set_color('none')
                    ax.xaxis.set_ticks_position('bottom')
                    ax.yaxis.set_ticks_position('left')
                    ax.set_xticks([])
                    ax.text(-0.1, 1.0, 'd',
                        horizontalalignment='center',
                        verticalalignment='center',
                        fontsize=20, fontweight='demibold',
                        transform=ax.transAxes)
                    
        
        
                    
                    ax = fig.add_subplot(gs[6:8])
                    bins = np.arange(xlim[0], xlim[1]+1)
                    hist = ax.hist(xe,
                        bins=bins,
                        color='r', label='exc', histtype='stepfilled', edgecolor='none',
                        rasterized=True)
                    hist = np.array(hist[0])
                    
                    ax.hist(xi,
                        bins=bins,
                        color='b', label='inh', histtype='stepfilled', edgecolor='none',
                        rasterized=True)
                    
                    ax.set_ylabel('spikes / ms')
                    ax.set_xlim(xlim[0], xlim[1])
                    ax.set_ylim(0, hist.max())
                    del hist
                    
                    leg = ax.legend()
                    for t in leg.get_texts():
                        t.set_fontsize('small')    # the legend text fontsize
        
                    for loc, spine in ax.spines.iteritems():
                        if loc in ['right', 'top']:
                            spine.set_color('none')
                    ax.xaxis.set_ticks_position('bottom')
                    ax.yaxis.set_ticks_position('left')
                    ax.set_xticks([])                
                    ax.text(-0.1, 1.0, 'e',
                        horizontalalignment='center',
                        verticalalignment='center',
                        fontsize=20, fontweight='demibold',
                        transform=ax.transAxes)
        
                    ax.set_title('spike count histogram')
                    
                    ax = fig.add_subplot(gs[8:])
                    bins = np.arange(xlim[0], xlim[1]+1)
                    hist = np.histogram(
                        xe,
                        bins=bins)[0]
                    ax.plot(bins[:-1], hist * 1000 / self.NE,
                            color='r', label='exc', rasterized=True)
                    
                    hist = np.histogram(
                        xi,
                        bins=bins)[0]
                    ax.plot(bins[:-1], hist * 1000 / self.NI,
                            color='b', label='inh', rasterized=True)
                    ax.set_xlabel(r'$t$ (ms)', labelpad=0.1)
                    ax.set_ylabel('rate (Hz)')
                    ax.set_xlim(xlim[0], xlim[1])
                    
                    leg = ax.legend()
                    for t in leg.get_texts():
                        t.set_fontsize('small')    # the legend text fontsize
        
                    for loc, spine in ax.spines.iteritems():
                        if loc in ['right', 'top']:
                            spine.set_color('none')
                    ax.xaxis.set_ticks_position('bottom')
                    ax.yaxis.set_ticks_position('left')
                    
                    ax.set_title('population firing rate (Hz)')
                    
                    ax.text(-0.1, 1.0, 'f',
                        horizontalalignment='center',
                        verticalalignment='center',
                        fontsize=20, fontweight='demibold',
                        transform=ax.transAxes)
            
            return fig


        if RANK == 0:
            fig = plt.figure(figsize=(10, 10))
            
            fig = plot_nonstat(fig, xlim)
            print('ok')
            fig = plot_rasters(fig, xlim, from_db)
            print('ok')

            
            return fig
        else:
            return


if __name__ == '__main__':
    #set nest verbosity
    nest.sli_run("%s setverbosity" % 'M_WARNING')
    
    #test different Network instances
    networks = [
        Network,
        StationaryPoissonNetwork,
        BrunelNetwork,
        RingNetwork,
        ExternalNoiseRingNetwork
    ]
    
    #corresponding parameters, only setting the network size.
    parameters = [
        dict(),
        dict(NE=4000, NI=1000),
        dict(order=1000),
        dict(N=5000),
        dict(N=5000,
             lambda_t=np.cos(5*2*np.pi*np.linspace(0., 1., 10001)),
             rate=20., weight=2.)
    ]
    
    for network, params in zip(networks, parameters):
        if RANK == 0:
            os.system('rm -r savedata')
        COMM.Barrier()
        
        print('\n\nTest {}\n\n'.format(network)) 
        net = network(**params)
        net.run()
        net.get_results()
        net.process_gdf_files()
        net.raster_plots()
    
        if network == ExternalNoiseRingNetwork:
            net.raster_plots_full()

    os.system('rm -r savedata')
    
    
    plt.show()
